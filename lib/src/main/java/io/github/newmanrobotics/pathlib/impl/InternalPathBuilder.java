/*
InternalPathBuilder.java
Copyright (C) 2025 Owen Kelley

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <https://www.gnu.org/licenses/>.
*/

package io.github.newmanrobotics.pathlib.impl;

import java.util.ArrayList;
import java.util.List;
import java.util.stream.Stream;

import io.github.newmanrobotics.pathlib.Path;
import io.github.newmanrobotics.pathlib.PathBuilder;
import io.github.newmanrobotics.pathlib.World;
import io.github.newmanrobotics.pathlib.data.BoundingBox;
import io.github.newmanrobotics.pathlib.data.PathBuilderFlags;
import io.github.newmanrobotics.pathlib.data.Position;
import io.github.newmanrobotics.pathlib.data.Vertex;

public class InternalPathBuilder implements PathBuilder {
    private PathBuilderFlags flags;
    private List<Position> targets = new ArrayList<>();
    private World world;

    /**
     * Prefer {@code PathBuilder.create()} to {@code new InternalPathBuilder()}.
     */
    public InternalPathBuilder(PathBuilderFlags flags) {
        this.flags = flags;
    }

    @Override
    public void setWorld(World world) {
        this.world = world;
    }

    @Override
    public PathBuilder addTarget(Position target) {
        this.targets.add(target);
        return this;
    }

    @Override
    public Path build() {
        /// TODO: Get this function to replace {@code this.targets} with a version generated by Astar.
        // Pad world
        World paddedWorld = this.world.pad(this.flags.avoidBoxSize());

        // Determine eligible vertices to build graph on.
        List<BoundingBox> boxes = paddedWorld.getObjects();
        List<Vertex> vertices = new ArrayList<>();
        for (int i = 0; i < boxes.size(); ++i) {
            BoundingBox box = boxes.get(i);

            Vertex loLoPos = new Vertex(box.fromX(), box.fromY());
            Vertex hiHiPos = new Vertex(box.toX(), box.toY());
            Vertex hiLoPos = new Vertex(box.toX(), box.fromY());
            Vertex loHiPos = new Vertex(box.fromX(), box.toY());

            boolean loLoEligible = true, loHiEligible = true, hiLoEligible = true, hiHiEligible = true;
            for (int j = 0; j < boxes.size(); ++j) {
                if (i == j) continue;
                BoundingBox trialBox = boxes.get(j);
                // There's a problem here: if we choose to allow points on the borders of boxes to be counted,
                // there will be duplicate points in certain places, potentially causing an infinite loop at the
                // Astar step. However, if we don't, some perfectly valid convex points won't appear at all.
                // I chose to disallow them because, otherwise, some concave points would be considered when they
                // really shouldn't be. However, I'm still a bit uneasy about this decision.
                if (loLoEligible && trialBox.isWithin(loLoPos.x(), loLoPos.y())) loLoEligible = false;
                if (hiHiEligible && trialBox.isWithin(hiHiPos.x(), hiHiPos.y())) hiHiEligible = false;
                if (loHiEligible && trialBox.isWithin(loHiPos.x(), loHiPos.y())) loHiEligible = false;
                if (hiLoEligible && trialBox.isWithin(hiLoPos.x(), hiLoPos.y())) hiLoEligible = false;
            }

            if (loLoEligible) vertices.add(loLoPos);
            if (loHiEligible) vertices.add(loHiPos);
            if (hiLoEligible) vertices.add(hiLoPos);
            if (hiHiEligible) vertices.add(hiHiPos);
        }

        // Astar generation goes here

        if (!this.flags.smooth()) {
            // Create path with sharp angles
            return new InternalPath(this.targets);
        }
        // Create smooth and continuous path
        throw new RuntimeException("Unimplemented branch: smooth path!");
    }
}
